(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{528:function(e,t,s){"use strict";s.r(t);var a=s(6),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"vue-父子页面如何通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-父子页面如何通信"}},[e._v("#")]),e._v(" vue 父子页面如何通信")]),e._v(" "),s("ul",[s("li",[e._v("父组件传递数据给子组件：可以通过 props 属性来实现")]),e._v(" "),s("li",[e._v("子组件与父组件通信：this.$emit('upup','hehe');")]),e._v(" "),s("li",[e._v("父组件监听子组件触发的 upup 事件")])]),e._v(" "),s("h2",{attrs:{id:"怎么管理-vue-里面的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么管理-vue-里面的状态"}},[e._v("#")]),e._v(" 怎么管理 vue 里面的状态")]),e._v(" "),s("p",[e._v("​ 通过 vuex 来管理")]),e._v(" "),s("p",[e._v("状态管理有 5 个核心，分别是 state、getter、mutation、action 以及 module")]),e._v(" "),s("p",[e._v("state 为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在 vue.js 的组件中才能获取你定义的这个对象的状态。")]),e._v(" "),s("p",[e._v("getter 有点类似 vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getter，getter 会接收 state 作为第一个参数，\n而且 getter 的返回值会根据它的依赖被缓存起来，只有 getter 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。")]),e._v(" "),s("p",[e._v("更改 store 中 state 状态的唯一方法就是提交 mutation，就很类似事件。\n每个 mutation 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函数中改变。\n我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。")]),e._v(" "),s("p",[e._v("action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有任何的异步操作。在页面中如果我们要用这个 action，则需要执行 store.dispatch")]),e._v(" "),s("p",[e._v("module 其实只是解决了当 state 中很复杂臃肿的时候，module 可以将 store 分割成模块，每个模块中拥有自己的 state、mutation、action 和 getter。")]),e._v(" "),s("h2",{attrs:{id:"active-class-是哪个组件的属性-嵌套路由怎么定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#active-class-是哪个组件的属性-嵌套路由怎么定义"}},[e._v("#")]),e._v(" active-class 是哪个组件的属性？嵌套路由怎么定义？")]),e._v(" "),s("p",[e._v("答：vue-router 模块的 router-link 组件。")]),e._v(" "),s("h2",{attrs:{id:"怎么定义-vue-router-的动态路由-怎么获取传过来的动态参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么定义-vue-router-的动态路由-怎么获取传过来的动态参数"}},[e._v("#")]),e._v(" 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？")]),e._v(" "),s("p",[e._v("答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 使用 router 对象的 params.id")]),e._v(" "),s("h2",{attrs:{id:"vue-router-有哪几种导航钩子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-有哪几种导航钩子"}},[e._v("#")]),e._v(" vue-router 有哪几种导航钩子？")]),e._v(" "),s("p",[e._v("答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件")]),e._v(" "),s("h2",{attrs:{id:"scss-是什么-安装使用的步骤是-有哪几大特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scss-是什么-安装使用的步骤是-有哪几大特性"}},[e._v("#")]),e._v(" scss 是什么？安装使用的步骤是？有哪几大特性？")]),e._v(" "),s("p",[e._v("答：预处理 css，把 css 当前函数编写，定义变量,嵌套。 先装 css-loader、node-loader、sass-loader 等加载器模块，在 webpack-base.config.js 配置文件中加多一个拓展:extenstion，再加多一个模块：module 里面 test、loader")]),e._v(" "),s("h2",{attrs:{id:"scss-是什么-在-vue-cli-中的安装使用步骤是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scss-是什么-在-vue-cli-中的安装使用步骤是"}},[e._v("#")]),e._v(" scss 是什么？在 vue.cli 中的安装使用步骤是？")]),e._v(" "),s("p",[e._v("答：css 的预编译。")]),e._v(" "),s("p",[e._v("使用步骤：")]),e._v(" "),s("p",[e._v("第一步：用 npm 下三个 loader（sass-loader、css-loader、node-sass）")]),e._v(" "),s("p",[e._v("第二步：在 build 目录找到 webpack.base.config.js，在那个 extends 属性中加一个拓展.scss")]),e._v(" "),s("p",[e._v("第三步：还是在同一个文件，配置一个 module 属性")]),e._v(" "),s("p",[e._v("第四步：然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss”")]),e._v(" "),s("h2",{attrs:{id:"scss-有哪几大特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scss-有哪几大特性"}},[e._v("#")]),e._v(" scss 有哪几大特性")]),e._v(" "),s("p",[e._v("1、可以用变量，例如（$变量名称=值）；")]),e._v(" "),s("p",[e._v("2、可以用混合器，例如（）")]),e._v(" "),s("p",[e._v("3、可以嵌套")]),e._v(" "),s("h2",{attrs:{id:"mint-ui-是什么-怎么使用-说出至少三个组件使用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mint-ui-是什么-怎么使用-说出至少三个组件使用方法"}},[e._v("#")]),e._v(" mint-ui 是什么？怎么使用？说出至少三个组件使用方法？")]),e._v(" "),s("p",[e._v("答：基于 vue 的前端组件库。npm 安装，然后 import 样式和 js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper")]),e._v(" "),s("h2",{attrs:{id:"v-model-是什么-怎么使用-vue-中标签怎么绑定事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model-是什么-怎么使用-vue-中标签怎么绑定事件"}},[e._v("#")]),e._v(" v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？")]),e._v(" "),s("p",[e._v("答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：<input @click=doLog() />")]),e._v(" "),s("h2",{attrs:{id:"axios-是什么-怎么使用-描述使用它实现登录功能的流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#axios-是什么-怎么使用-描述使用它实现登录功能的流程"}},[e._v("#")]),e._v(" axios 是什么？怎么使用？描述使用它实现登录功能的流程？")]),e._v(" "),s("p",[e._v("答：请求后台资源的模块。npm install axios -S 装好，然后发送的是跨域，需在配置文件中 config/index.js 进行设置。后台如果是 Tp5 则定义一个资源路由。js 中使用 import 进来，然后.get 或.post。返回在.then 函数中如果成功，失败则是在.catch 函数中")]),e._v(" "),s("h2",{attrs:{id:"axios-tp5-进阶中-调用-axios-post-api-user-是进行的什么操作-axios-put-api-user-8′-呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#axios-tp5-进阶中-调用-axios-post-api-user-是进行的什么操作-axios-put-api-user-8′-呢"}},[e._v("#")]),e._v(" axios+tp5 进阶中，调用 axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？")]),e._v(" "),s("p",[e._v("答：跨域，添加用户操作，更新操作。")]),e._v(" "),s("h2",{attrs:{id:"什么是-restful-api-怎么使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-restful-api-怎么使用"}},[e._v("#")]),e._v(" 什么是 RESTful API？怎么使用")]),e._v(" "),s("p",[e._v("答：是一个 api 的标准，无状态请求。请求的路由地址是固定的，如果是 tp5 则先路由配置中把资源路由配置好。标准有：.post .put .delete")]),e._v(" "),s("h2",{attrs:{id:"vuex-是什么-怎么使用-哪种功能场景使用它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-是什么-怎么使用-哪种功能场景使用它"}},[e._v("#")]),e._v(" vuex 是什么？怎么使用？哪种功能场景使用它？")]),e._v(" "),s("p",[e._v("答：vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")]),e._v(" "),s("h2",{attrs:{id:"mvvm-框架是什么-它和其它框架-jquery-的区别是什么-哪些场景适合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-框架是什么-它和其它框架-jquery-的区别是什么-哪些场景适合"}},[e._v("#")]),e._v(" mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？")]),e._v(" "),s("p",[e._v("答：一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个")]),e._v(" "),s("p",[e._v("区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。")]),e._v(" "),s("p",[e._v("场景：数据操作比较多的场景，更加便捷")]),e._v(" "),s("h2",{attrs:{id:"自定义指令-v-check、v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令-v-check、v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数"}},[e._v("#")]),e._v(" 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？")]),e._v(" "),s("p",[e._v("答：全局定义指令：在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives")]),e._v(" "),s("p",[e._v("钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）")]),e._v(" "),s("p",[e._v("钩子函数参数：el、binding")]),e._v(" "),s("h2",{attrs:{id:"说出至少-4-种-vue-当中的指令和它的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说出至少-4-种-vue-当中的指令和它的用法"}},[e._v("#")]),e._v(" 说出至少 4 种 vue 当中的指令和它的用法？")]),e._v(" "),s("p",[e._v("答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定")]),e._v(" "),s("h2",{attrs:{id:"vue-router-是什么-它有哪些组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-是什么-它有哪些组件"}},[e._v("#")]),e._v(" vue-router 是什么？它有哪些组件？")]),e._v(" "),s("p",[e._v("答：vue 用来写路由一个插件。router-link、router-view")]),e._v(" "),s("h2",{attrs:{id:"导航钩子有哪些-它们有哪些参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导航钩子有哪些-它们有哪些参数"}},[e._v("#")]),e._v(" 导航钩子有哪些？它们有哪些参数？")]),e._v(" "),s("p",[e._v("答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave")]),e._v(" "),s("p",[e._v("参数：有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种")]),e._v(" "),s("h2",{attrs:{id:"vue-的双向数据绑定原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向数据绑定原理是什么"}},[e._v("#")]),e._v(" Vue 的双向数据绑定原理是什么？")]),e._v(" "),s("p",[e._v("答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),e._v(" "),s("p",[e._v("具体步骤：")]),e._v(" "),s("p",[e._v("第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter\n这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化")]),e._v(" "),s("p",[e._v("第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),s("p",[e._v("第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\n1、在自身实例化时往属性订阅器(dep)里面添加自己\n2、自身必须有一个 update()方法\n3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。")]),e._v(" "),s("p",[e._v("第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。")]),e._v(" "),s("p",[e._v("ps：16 题答案同样适合”vue data 是怎么实现的？”此面试题。")]),e._v(" "),s("h2",{attrs:{id:"请详细说下你对-vue-生命周期的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请详细说下你对-vue-生命周期的理解"}},[e._v("#")]),e._v(" 请详细说下你对 vue 生命周期的理解？")]),e._v(" "),s("p",[e._v("答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。")]),e._v(" "),s("p",[e._v("创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，$el 还没有。")]),e._v(" "),s("p",[e._v("载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。")]),e._v(" "),s("p",[e._v("更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。")]),e._v(" "),s("p",[e._v("销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在")]),e._v(" "),s("h2",{attrs:{id:"请说下封装-vue-组件的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请说下封装-vue-组件的过程"}},[e._v("#")]),e._v(" 请说下封装 vue 组件的过程？")]),e._v(" "),s("p",[e._v("答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。")]),e._v(" "),s("p",[e._v("然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。")]),e._v(" "),s("h2",{attrs:{id:"你是怎么认识-vuex-的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你是怎么认识-vuex-的"}},[e._v("#")]),e._v(" 你是怎么认识 vuex 的？")]),e._v(" "),s("p",[e._v("答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。\n通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。")]),e._v(" "),s("p",[e._v("应用级的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。")]),e._v(" "),s("h2",{attrs:{id:"vue-loader-是什么-使用它的用途有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader-是什么-使用它的用途有哪些"}},[e._v("#")]),e._v(" vue-loader 是什么？使用它的用途有哪些？")]),e._v(" "),s("p",[e._v("答：解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。")]),e._v(" "),s("p",[e._v("用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等")]),e._v(" "),s("h2",{attrs:{id:"请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法"}},[e._v("#")]),e._v(" 请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？")]),e._v(" "),s("p",[e._v("答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置;view 视图；app.vue 是一个应用主组件；main.js 是入口文件")]),e._v(" "),s("h2",{attrs:{id:"vue-cli-中怎样使用自定义的组件-有遇到过哪些问题吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-cli-中怎样使用自定义的组件-有遇到过哪些问题吗"}},[e._v("#")]),e._v(" vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？")]),e._v(" "),s("p",[e._v("答：第一步：在 components 目录新建你的组件文件（smithButton.vue），script 一定要 export default {")]),e._v(" "),s("p",[e._v("第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’")]),e._v(" "),s("p",[e._v("第三步：注入到 vue 的子组件的 components 属性上面,components:{smithButton}")]),e._v(" "),s("p",[e._v("第四步：在 template 视图 view 中使用，"),s("code",[e._v("<smith-button> </smith-button>")]),e._v("\n问题有：smithButton 命名，使用的时候则 smith-button。")]),e._v(" "),s("h2",{attrs:{id:"聊聊你对-vue-js-的-template-编译的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聊聊你对-vue-js-的-template-编译的理解"}},[e._v("#")]),e._v(" 聊聊你对 Vue.js 的 template 编译的理解？")]),e._v(" "),s("p",[e._v("答：简而言之，就是先转化成 AST 树，再得到的 render 函数返回 VNode（Vue 的虚拟 DOM 节点）")]),e._v(" "),s("p",[e._v("详情步骤：")]),e._v(" "),s("p",[e._v("首先，通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。")]),e._v(" "),s("p",[e._v("然后，AST 会经过 generate（将 AST 语法树转化成 render funtion 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有（标签名、子节点、文本等等）")])])}),[],!1,null,null,null);t.default=v.exports}}]);